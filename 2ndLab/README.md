# 2nd-Lab

Ο gem5 χρησιμοποιεί τα παρακάτω χαρακτηριστικά μνήμης επεξεργαστή:
L1 instruction cache με size=32768B, assoc=2 και block_size=64B
L1 data cache με size=65536B, assoc=2 και block_size=64B
L2 cache με size=2097152B, assoc=8 και block_size=64B

Στον φάκελος spec_results υπάρχουν τα output των gem5 simulations για κάθε benchmark. Μέσα στον κάθε φάκελο υπάρχει αρχείο info.txt που περιέχει τις πληροφορίες: sim_seconds, cache.overall_miss_rate::total για κάθε είδος cache.
3.Σχετικά με τις εισαγωγές system clk και  cpu clk  η μεν δεύτερη ειναι η ταχύτητα του  επεξεργαστή ενώ η πρώτη αφορά τη
συχνότητα λειτουργίας των υπόλoιπων λειτουργικων μοναδων του συστηματος (πχ membus).
Αναζητώντας πληροφορίες στο αρχείο config.json συλλέξαμε τις εξής : 1) membus, dvfs handler(dynamic voltage frequency scaling)
,tags(της μνήμης) χρονίζονται στη ταχύτητα system clk domain.  
2) cpu ,tol2bus ,walker  χρονίζονται στη συχνότητα system cpu clk domain.
Κατά την αναζήτηση μελετήσαμε τα block των κλασεων (cpu ,system κτλπ) ,όπου προέκυψαν οι παραπάνω ταχύτητες ως τιμές
αρχικοποίησης των κλάσεων αυτών.
Αν προσθέταμε ακόμα έναν επεξεργαστή αυτος θα χρονιζόταν στην τιμή system cpu clk.

Scaling 1GHz vs 2GHz:
specbzip: 1.91
spechmmer: 1.995
speclibm: 1.501
specsjeng: 1.37
specmcf: 1.967

Όπως προκύπτει  με εξαιρεση τα b/m speclibm και specsjeng  εχουμε τέλειο scalling.
Για το speclib  τα cpi στα 2ghz ειναι περισσότερα κατα 1.33 φορες, τα read και write memory bandwidth είναι 1.5019 φορες
μεγαλυτερα ,το average icache overall miss latency ειναι μικροτερο κατα 1/1.336.Επίσης στα 1ghz εχω ελαχιστα περισσότερα hits
και ελαχιστα λιγότερα misses στη dcache.
Παρατηρόυμε οτι οι αναλογίες που φτιάξαμε ειναι κοντά στο scalling των χρόνων εκτέλεσης,καθως και οτι στα `1ghz εχω ορθότερη
προσπέλαση δεδομένων στην dcache.

Για το specsjeng   τα cpi στα 2ghz  ειναι 1.45 φορες περισσοτερα ,τα read και write bandwidth  1,37 φορες μεγαλύτερα,το average
icache overall miss latency μικροτερο κατα 1/1.29 .Τωρα ,στα 1 ghz  εχω ελαχιστα λιγοτερα hits και ελαχιστα περισσότερα misses.
Με την ιδια λογική  προκύπτει το αποτέλεσμα του scalling.
Συμεπερασματικά , η  δομή του benchmark απο άποψη κώδικα οδηγεί σε συγκεκριμένες προσβάσεις στην μνήμη και επομένως ο χρόνος
εκτέλεσης επηρεάζεται απο data buses ,latency of memory και απο την αρχιτεκτονική  των cache.

#### Μέρος 2ο

Κάναμε επιλογες μεγεθών αρχίζοντας απ το cache line size, στο οποίο παρατηρούμε τη μεγαλύτερη διαφορα CPI σε σχέση με τις αλλαγές των υπόλοιπων επιλογών. Αφού βρουμε το βέλτιστο CPI για συγκεκριμένο cache line size, κανουμε αλλαγές πρωτα της l2 που εχει και μεγαλυτερο οριο και μετα της l1d και l1i.

Για το specbzip παρατηρω οτι η  assocli1 ,ld1,l2 της μορφης 2,2,8  δίνει χαμηλούς κύκλους,σε σχεση με μια μορφη 1,1,4 η οποία αποδικνύεται καταστροφική.Με υψηλη συσχετικότητα εχω λιγότερες αστοχίες σύγκρουσης και ετσι μειώνεται το miss rate.Βέβαια η αρκετα υψηλή οδηγεί σε επιβάρυνση του cpi.Το μήκος του μπλοκ δέν φαίνεται να επηρεάζει σημαντικά σε τιμες 64 και 128,οχι όμως και σε τιμες 512 kb οπου αυξάνει το miss penalty.Γενικά οι αλλαγές μεγέθους σε l1i ,l1d ,l2 έχουν ισάξια επιρροή στο ρολόι,κυρίως μια μεγάλη διαφορά μεγεθους  μεταξυ l1 και l2 είναι αυτή που οδηγεί σε χαμηλούς χρόνους γιατί όσο μικρότερες ειναι οι l1  μειώνεται ο χρονος ευστοχίας,ωστοσο πρέπει να προσέξουμε ποσο μικρή  l1 θα βάλουμε για να αποφύγουμε το ''αλώνισμα''.

Για το specshmmer παρατηρώ οτι καθοριστικός παράγοντας για τη βελτίωση του cpi  ειναι το  μεγάλος μεγεθος(128 kB) την κρυφής μνήμης πρωτου επιπεδου, προφανώς οι λιγότερες αστοχίες χωρητικότητας που έχω μειώνουν το miss rate και υπερκεράζουν τον χρόνο ευστοχίας   .Μεγάλο μήκος μπλόκ(512 κΒ) και χαμηλή l1(64κΒ) αυξάνουν κατακόρυφα το cpi λόγω του υψηλού miss rate στην l1  και της μεγάλης ποινής αστοχίας.Η συσχετικότητα δεν έχει μεγάλη επιρροή σε αυτο το πρόγραμμα.

Για το πρόγραμμα speclibm δεν υπάρχει μεγάλη επιρροή της συσχετικότητας.Μεγάλο ρόλο παίζει το μήκος μπλόκ όπου τα 256 kB αρκούν για να μας δώσουν αρκέτα καλόυς χρόνους ,απο την άλλη μικρο μπλοκ στα 32 αυξάνει τον ρυθμό αστοχίας καθώς μικρή cache line δεν  μπορεί να μεταφέρει πολλά δεδομένα.Υψηλή l1(192 kB) και l2(1024 kB) βελτιώνουν πολύ το cpi αξιοποιόντας το locality.

Για το specmcf  είναι ξεκάθαρο οτι πολυ μικρή  l1 σε σχέση με την l2 δημιουργούν το φαινόμενο 'αλώνισμα) διότι έχω πολυ υψηλό miss rate l1 και αναγκάζεται το πρόγραμμα να ανασύρει δεδομένα απο το δεύτερο επίπεδο.Αυτό κοστίζει σε χρονο και κύκλους.Υψηλή l1 και l2 σε συνδιασμό με μήκος block 128 kB μας δίνουν εξαιρετική απόδοση.

Για το specsjeng με τα δεδομένα specs που επιλέξαμε έχουμε μια λογαριθμική κλιμάκωση.Ειναι προφανές οτι το πιο σημαντικό είναι το μεγάλο μήκος μπλοκ(2048 kB) ωστε να έχω σε κάθε κύκλο ανάσυρση όσο  το δυνατον περισσότερων δεδομένων.Μερίδιο στη βελτίωση του χρόνου κατέχει και η αρκετα μεγάλη κρυφή μνήμη πρώτου επιπέδου (256  κΒ) η οποία μειώνει τις αστοχίες χωρητικότητας ,άρα και το  miss rate ,  επιπλέον μνήμη δεύτερου επιπέδου μεσαίου μεγεθους (512 κΒ) συμβάλλει και στη γρήγορη προσπέλαση δεδομένων όταν  έχω miss στο πρώτο επίπεδο.Μεγαλύτερη μνήμη 2ου επιπέδου επιβραδύνει έστω και ελάχιστα τον χρόνο εκτέλεσης.

Τα διαγράμματα μας για κάθε benchmark βρίσκονται στον φακελο Part2Graphs.

#### Μέρος 3ο



Πηγές:
https://en.wikipedia.org/wiki/Clock_rate


__By Panos Petridis & Theofilos Panagiotou__
